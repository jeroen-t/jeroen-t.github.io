[{"categories":["Learning"],"content":"A write-up on what I have learned so far about Azure Bicep Lang","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"Getting started with Azure Bicep In this post I will take you through deploying resources to Azure using templates. We will be creating these templates using Azure Bicep. ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:0:0","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"üìã Prerequisites ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:1:0","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"[‚úî] Azure CLI The first thing we will need is the Azure command-line interface (Azure CLI). This is a set of commands that can interact with Azure and its resources. You can get the Azure CLI through the winget tool. winget install Microsoft.AzureCLI Or any of the other methods mentioned in the documentation: Install the Azure CLI. Once succesfully installed you can simply run az in your terminal to see a list of all the base commands. ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:1:1","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"[‚úî] The Bicep Lang extension Now that we have the Azure CLI installed we are going to install the Bicep extension. You may have already seen it pop up when you ran the az command. Simply run the following command to install the Bicep CLI: az bicep install If you already had the extension installed this may have been because you already ran an Azure CLI command that depends on the Bicep CLI. The Bicep CLI will automatically get installed if this is the case. You can check your Bicep version by running: az bicep version and if it is not the latest then upgrade by running: az bicep upgrade if you have never touched the CLI before then checkout some of the commands by including -h / ‚Äìhelp at the end. ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:1:2","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"[‚úî] VS Code Bicep Extension I highly suggest using a code editor. My editor of choice is Visual Studio Code. Especially since it has the Bicep extension. To install VS Code run: winget install Microsoft.VisualStudioCode or for a bunch of other methods visit VS Code setup overview. Once you have Visual Studio Code installed. Open VS Code and go to the extensions tab. Search for ‚Äúbicep‚Äù and select install. You can verify whether the extension installed succesfully by creating a file with the .bicep extension. Save it and then check whether it picks up any of the IntelliSense features. ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:1:3","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"[‚úî] PowerShell AZ module I am used to working with PowerShell so in this post I will be using the pwsh az module. This is optional. If you want to follow along then run the below commands in a PowerShell terminal. # PowerShell script execution policy must be set to remote signed or less restrictive Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # Works cross-platform - PowerShell 7.x and later is recommended Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force Another option is using the Azure CLI we installed earlier. üëç ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:1:4","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"[‚úî] An Azure Subscription (Optional) And of course if we want to deploy to Azure we are going to need an Azure Account with an active Subscription on which we have permissions so that we can deploy resources. If you are new to Azure you can create an Azure free account. This will give you access to free tier services for 12 months and a $200 budget which you can spend within 30 days from signing up. Noticed that I put within 30 days in bold? Don‚Äôt sign up late at night and think I will look at it tomorrow. Nah dude, we don‚Äôt have time to lose! Sign up for this at a time that you know you have some time to spend. You can Start free here. And if you are a student you can try Azure without having to sign up with a credit card. Checkout the students page. In case you can‚Äôt signup for any of the offers above and don‚Äôt have access to an active subscription you can checkout the Microsoft Learn site. You are limited with what you can do depending on what course you follow but that is not a problem. They have a wide variety of courses available (especially when it comes to Azure) and more and more of their courses come with a Sandbox environment. These Sanbox environment let you perform tasks in Azure (based on the course description) without needing an Azure account. And best of all no charging at all. Completely free! Downside is of course that you can‚Äôt save any of your work but I mean for learning purposes it is wise to delete all your deployed resources at the end of your learning sessions anyway. Unless you like to be a big spender. üí∞ Go over the options I have just listed and make your decision. Once you are all set we can go on our adventure. You can also just do the reading thing. That is cool as well! ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:1:5","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"üë®‚Äçüè´ Azure Resource Manager Whenever you want to deploy resources to Azure you are going to interact with the Azure Resource Manager (ARM). Whether you are using the Azure Portal, Azure Powershell, the Azure CLI or the Azure REST APIs. As you can imagine it is important for the ARM service to be available at all times. It is designed to be resilient and continuously available. Think: Distributed services across regions No dependencies on a single data center No downtime during maintenace et cetera. No need for us to worry about all of that. We want to deploy and they will let us. How are we deploying things? Behind the scenes everything in Azure is stored in JSON format. JSON format\r\rJSON is a lightweight data-interchange format that is self describing and easy to read and understand. This site shows examples messages formatted using JSON (and a comparison with the same text as XML).\r\r You can verify this within the Azure portal. The portal is accessible through portal.azure.com. When you have deployed a resource you can access that resource and export the template. For example let‚Äôs say we create a Resource Group through the portal: Once you click on the button Review + create you will get a last overview of the resource you are about to deploy and at the bottom right you will get an option to download the template. If we press download we get the deployment template and we can also choose whether or not we want a parameter template with the values we have supplied earlier. In our case we get the following files: Template.json: { \"$schema\": \"https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#\", \"contentVersion\": \"1.0.0.1\", \"parameters\": { \"rgName\": { \"type\": \"string\" }, \"rgLocation\": { \"type\": \"string\" }, \"tags\": { \"type\": \"object\", \"defaultValue\": {} } }, \"variables\": {}, \"resources\": [ { \"type\": \"Microsoft.Resources/resourceGroups\", \"apiVersion\": \"2018-05-01\", \"location\": \"[parameters('rgLocation')]\", \"name\": \"[parameters('rgName')]\", \"properties\": {}, \"tags\": \"[parameters('tags')]\" } ], \"outputs\": {} } along with its parameter file. parameters.json: { \"$schema\": \"https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#\", \"contentVersion\": \"1.0.0.0\", \"parameters\": { \"rgName\": { \"value\": \"new-resourcegroup\" }, \"rgLocation\": { \"value\": \"westeurope\" }, \"tags\": { \"value\": {} } } } See, easy to understand. Right? :-) Or you could checkout the Azure Resource Explorer on resources.azure.com. This is currently in preview and allows you to view the API and make API calls directly into your own subscriptions. Because all of the earlier mentioned tools (portal, cli, etc) make requests through the same APIs you will see consistent results. All requests are handled using JSON. To showcase our Resource Group example of earlier we could simply run: So if we want to create the same resource group as earlier we would have to provide values for the Resource Name, the resource id, the name and its location. But if all requests are in JSON format anyways then wouldn‚Äôt it be a good idea to deploy these templates directly? Yup, good question. That brings us to a concept called ‚ÄúInfrastructure as Code‚Äù and ARM templates. ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:2:0","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"‚ùì What are ARM Templates? As we have seen earlier with our Resource Group deployment we can deploy resources to Azure using a template that is written in JSON format. Such a template is called an Azure Resource Manager template or ARM template in short. A template is declarative that means that in your ARM template you describe what you want. How to get to that state and what operations need to be done? Well, we don‚Äôt care. Azure will take care of all of that. Take into account that we provide the correct resources and their properties. And even if we didn‚Äôt the Azure Resource Manager has a built-in validation that will check the template before doing the actual deployment. If there is something wrong with the resource that we are trying to deploy then it will tell us and we are not stuck with only half of the deployment. ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:2:1","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"{ } The ARM Template syntax A basic template file contains the sections: Parameters, Variables, Resources and Outputs. You can also use functions in your ARM template. Checkout the documentation for a full list of functions. The sections mentioned in ARM template format will look like this: { \"$schema\": \"https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\", \"contentVersion\": \"1.0.0.0\", \"parameters\": {}, \"variables\": {}, \"resources\": [], \"outputs\": {} } We could make it even more minimalistic because the only keys that are required are the schema, content version and resources. We could remove the others however they have their use case so it is best to utilize them. The parameters section is used for input. That way we don‚Äôt have to hardcode each and every property and it gives us a way to reuse our templates. Handy! You can define variables using complicated expressions. You can for instance have a parameter that allows ‚ÄúQA‚Äù or ‚ÄúPRD‚Äù as input and based on the supplied value define a variable that will use a certain tier of a resource. Perhaps a Standard tier when deploying to QA and a Premium tier when that same resource gets deployed onto Production. And last but not least the outputs section. This is pretty straight forward. If you want to return any values from your deployed you can specify that. In practice a template we can deploy will look something like this: { \"$schema\": \"https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\", \"contentVersion\": \"1.0.0.0\", \"parameters\": { \"webAppName\": { \"type\": \"string\", \"defaultValue\": \"[concat('webApp-', uniqueString(resourceGroup().id))]\", \"minLength\": 2, \"metadata\": { \"description\": \"Unique name of the app to create or update.\" } }, \"location\": { \"type\": \"string\", \"defaultValue\": \"[resourceGroup().location]\", \"metadata\": { \"description\": \"Location of the resources. Default is RG location.\" } }, \"sku\": { \"type\": \"string\", \"defaultValue\": \"F1\", \"allowedValues\": [ \"B1\", \"B2\", \"B3\", \"F1\" ], \"metadata\": { \"description\": \"The SKU of App Service Plan.\" } }, \"linuxFxVersion\": { \"type\": \"string\", \"defaultValue\": \"DOTNETCORE|3.0\", \"metadata\": { \"description\": \"The Runtime stack of current web app\" } } }, \"variables\": { \"appServicePlanPortalName\": \"[concat('AppServicePlan-', parameters('webAppName'))]\" }, \"resources\": [ { \"name\": \"[variables('appServicePlanPortalName')]\", \"type\": \"Microsoft.Web/serverfarms\", \"apiVersion\": \"2020-06-01\", \"location\": \"[parameters('location')]\", \"sku\": { \"name\": \"[parameters('sku')]\" }, \"kind\": \"linux\", \"properties\": { \"reserved\": true } }, { \"name\": \"[parameters('webAppName')]\", \"type\": \"Microsoft.Web/sites\", \"apiVersion\": \"2020-06-01\", \"location\": \"[parameters('location')]\", \"dependsOn\": [ \"[resourceId('Microsoft.Web/serverfarms', variables('appServicePlanPortalName'))]\" ], \"properties\": { \"serverFarmId\": \"[resourceId('Microsoft.Web/serverfarms', variables('appServicePlanPortalName'))]\", \"siteConfig\": { \"linuxFxVersion\": \"[parameters('linuxFxVersion')]\" } } } ] } As you can see in the resources section we have specified two resources. A resource of the type Microsoft.Web/serverfarms and a resource of the type Microsoft.Web/sites. Please not that in the second resource we do have to specify a dependsOn key with the resource id of the serverfarm. This is because we need to have an app service plan in place before we can deploy a web app so it is key that one gets deployed before the other. So far things have been going great. We can easily specify what we want to deploy and it is easy to read what we are deploying. The things is though that once you deploy more and more resources using the same template. Your template will get bigger and bigger. That‚Äôs a hell of a lot of curly braces! And the whole easy to read thing will not be so easy anymore and may even get confusing once you add in a bunch of depends on keys. Writing a template like this doesn‚Äôt feel natural either. Most of the time you have to copy \u0026 pa","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:2:2","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"üí™ Project Bicep Your expectations must be pretty high right now and that is good because they should be. Throws a front double bicep. A default resource in Bicep will look like the following. If you want to see this for yourself then simply open a file with the .bicep file extension in VS Code. If you type res a dropdown will appear which a bunch of snippets. If you select resource with defaults you will get the below code. resource Identifier 'Provider/Type@Version' = { name: 'name' location: 'location' properties: { } } Let‚Äôs break this down for a bit. We have the resource keyword which we also saw in our ARM template. Nothing new there, it is known. The Identifier keyword we haven‚Äôt seen before. If you have seen some bicep tmeplates before then you might have seen being mentioned as a symbolicName. This is not the name of the resource. That wouldn‚Äôt make sense either since we already have a name property on the next line. Instead the Identifier is the name that we can give our resource so that we can reference it by that name throughout our template. Really useful stuff! And then last but not least we have the Provider, Type and Version. We had those in our ARM templates as well but instead having them each as separate properties in our template we just specify them in the resource declaration. It‚Äôs a lot clearer this way in my opinion. I know what you always wanted to have is an Azure Container Registry. I can‚Äôt give you that. Here, have it‚Äôs bicep template instead. Here ya go bud! resource acr 'Microsoft.ContainerRegistry/registries@2019-12-01-preview' = { name: 'nicelookingacrbro' location: 'West Europe' sku: { name: 'Basic' } properties: { adminUserEnabled: true } } ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:3:0","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"üéà More sections You might be thinking now ‚Äúwhere are the rest of our sections. I don‚Äôt see any curly braces.‚Äù. Yup, time to add some. Parameters first that is. @minLength(5) @maxLength(30) @description('The name of the container registry') param acrName string = 'acrgiveanyname' @description('The value that indicates whether the admin user is enabled.') param acrAdminUserEnabled bool = false @description('The location of the resource. This cannot be changed after the resource is created.') param location string = resourceGroup().location @allowed([ 'Basic' 'Standard' 'Premium' ]) @description('The SKU of the container registry.') param acrSku string = 'Basic' // azure container registry resource acr 'Microsoft.ContainerRegistry/registries@2019-12-01-preview' = { name: acrName location: location sku: { name: acrSku } properties: { adminUserEnabled: acrAdminUserEnabled } } You may have noticed two things. We have added parameters above our resource declaration and we have referenced the parameters by their name. To put this into comparison with ARM the acrSku parameter would be defined as: \"acrSku\": { \"type\": \"string\", \"defaultValue\": \"Basic\", \"metadata\": { \"description\": \"Tier of your Azure Container Registry.\" }, \"allowedValues\": [ \"Basic\", \"Standard\", \"Premium\" ] } and we would have to reference it in our resource like: \"sku\": { \"name\": \"[parameters('acrSku')]\" }, Bicep is cleaner. I think there is not much else to parameters. I do want to touch on the symbolicName part mentioned earlier though. We‚Äôll check that out by adding an output section to our template. I thought of displaying the whole code here however we only need to add one line to our previous Bicep template. I don‚Äôt think that is worth it so I will just mention that part but imagine it being part of the same template. When we create an Azure Container Registry we will have to give it a name. So let‚Äôs say we create an ACR with the name theirontemple and we want to push an image to that registry. In order to push an image to our newly created registry we need to know the value of the login server, which is a fuly qualified name ending with azurecr.io. So instead of looking this up after deployment we want our deployment to output this Login server name once we deployed our ACR. Our output will be: output acrLoginServer string = acr.properties.loginServer We are saying give me the output value for the login Server which in our case will be theirontemple.azurecr.io and store it in acrLoginServer. Notice the acr? That is the symbolicName we gave our resource. If you have VS Code open then remove the properties.loginServer and you will see all the outputs properties that you could specify. Now that we have covered a few of the basics of an Bicep template. Let‚Äôs see what that ‚Äúbig‚Äù ARM template that we used earlier looks like in Bicep. ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:3:1","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"üõ† Decompile / Build It is fast and easy to write it all in Bicep from scratch but why would we do that when we have the az bicep decompile function available to us? If I run this against our earlier template: az bicep decompile -f .\\deploy.json We get the following message: decompile warning\r\rWARNING: Decompilation is a best-effort process, as there is no guaranteed mapping from ARM JSON to Bicep. You may need to fix warnings and errors in the generated bicep file(s), or decompilation may fail entirely if an accurate conversion is not possible. If you would like to report any issues or inaccurate conversions, please see https://github.com/Azure/bicep/issues.\r\r Ours is looking great though (the template went from 74 lines of code to 43!): @description('Unique name of the app to create or update.') @minLength(2) param webAppName string = 'webApp-${uniqueString(resourceGroup().id)}' @description('Location of the resources. Default is RG location.') param location string = resourceGroup().location @description('The SKU of App Service Plan.') @allowed([ 'B1' 'B2' 'B3' 'F1' ]) param sku string = 'F1' @description('The Runtime stack of current web app') param linuxFxVersion string = 'DOTNETCORE|3.0' var appServicePlanPortalName_var = 'AppServicePlan-${webAppName}' resource appServicePlanPortalName 'Microsoft.Web/serverfarms@2020-06-01' = { name: appServicePlanPortalName_var location: location sku: { name: sku } kind: 'linux' properties: { reserved: true } } resource webAppName_resource 'Microsoft.Web/sites@2020-06-01' = { name: webAppName location: location properties: { serverFarmId: appServicePlanPortalName.id siteConfig: { linuxFxVersion: linuxFxVersion } } } dependsOn\r\rNotice that this time we do not have to specify a dependsOn property. That is because we are referencing the symbolic name of the app service plan. See the value of the serverFarmId property in the web app resource. appServicePlanPortalName.id.\r\r This works both ways. We can also write our code in Bicep first and decide to run az bicep build --file {bicep_file.bicep}. If we run that then it will spit out the ARM template for us. We could also just leave it as a bicep file and deploy the bicep file directly to Azure. For instance by running: New-AzResourceGroupDeployment -ResourceGroup \"yadayada\" -TemplateFile \"main.bicep\" -... ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:3:2","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Learning"],"content":"üí° Conclusion In this post we have learned a bit about what the Azure Resource Manager is, how we can deploy resources to Azure, What an ARM template is and of course Azure Bicep. I also wanted to touch on using modules in Bicep however I‚Äôm still playing around with these myself. I might edit this post later to include a section about this as well. They are great. If you throw a bunch of dummy workout plan files in there then whenever your SO/Friends/Family accidently stumble upon your project they will think you are finally serious about working out instead of it being another one of those side projects of yours.. üòâ That was it. I hope you enjoyed it and have learned something. Now it is time for you to roll up your sleeves üí™ If you want to learn more about Bicep I suggest the following resources: The official Azure Bicep Repo and it‚Äôs documentation The Bicep Playground in which you can have a look at some sample templates and try some tweaking yourself The Microsoft Learn Paths. Some of these have those sandboxes available of which I was talking about. The book: Getting started with Bicep: Infrastructure as code on Azure by Freek Berson. Btw, I discovered GIMP. It‚Äôs great üòâ ","date":"05-08-2021","objectID":"/2021/08/azure-bicep-intro/:4:0","tags":["Azure","ARM","Bicep","Cloud"],"title":"Azure Bicep: The First Pump","uri":"/2021/08/azure-bicep-intro/"},{"categories":["Documentation","Learning"],"content":"A step-by-step tutorial on how to create a PowerShell Module and publish it to the PSGallery by using GitHub Actions","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"A step-by-step tutorial on how to create a PowerShell Module and publish it to the PSGallery by using GitHub Actions You might be like me. Use PowerShell daily. Oneliners most of the time. For more advanced tasks you write a script and perhaps schedule those by using Task Scheduler, the SQL Server Agent or something similar. But creating a PowerShell module? Publishing it to the PowerShellGallery? Crazy! I‚Äôm by no means an expert but I got it working. So if you are interested then try to follow along. You might learn something new. I sure did! üòé ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:0:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"üìã Prerequisites ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:1:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"[‚úî] GitHub Account I‚Äôm hosting the source code of my module in a Git repository on GitHub. If you are interested in doing the same you should create a GitHub account if you don‚Äôt already have one. They have a free plan available and the process is straight forward. Just go to their site to sign up. ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:1:1","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"[‚úî] Git in PowerShell The posh-git package that provides integration between Git and PowerShell. It will display Git status summary information in your PowerShell prompt and provides support for tab completion when working with Git commands, branches, paths, etc. I want it ü§ó Follow the process as described on their site on how to install it. ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:1:2","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"[‚úî] Pester Pester is available on Windows 10 or later by default. You can check whether you have this module installed by running: Get-Module Pester -ListAvailable The 3.4.0 version ships as part of Windows 10 and is a bit problematic. To avoid headaches I would suggest updating it right away. Unfortunately updating the module using the Update-Module cmdlet won‚Äôt work. So you will have to install the latest version of Pester side-by-side using the follow tactic. Open PowerShell as Admin and run the following command: Install-Module -Name Pester -Force -SkipPublisherCheck Now if you run the following command again: Get-Module Pester -ListAvailable It will display both the shipping and the latest version of Pester. ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:1:3","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"[‚úî] Visual Studio code I highly suggest using a code editor. My editor of choice is Visual Studio Code. To install VS Code run: winget install Microsoft.VisualStudioCode the winget tool\r\rThe winget tool is the client interface to the Windows Package Manager service. You can use it to search for and/or install applications. It also has some other commands in store that allow you to display installed packages, export/import, validate and a bunch of more useful stuff. Once you have it installed simply run winget to see all commands that are available. You can read more about winget here\r\r And of course if you prefer a different editor yourself than you can use that one instead. ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:1:4","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"üìÇ Prepare your Git repository I hope you have read through the prerequisites and signed up for GitHub because GitHub is where we start. We are going to set up the Git repository (repo) for our module. Click on your profile in the top right of the page. A menu will open. Click on Your repositories. We are going to create a new repository so click on New. Provide a meaningful name for your repository. I provided the name of the module I created. Optionally you can give a description for you repository as well. Another decision you will have to make is whether you want your repository publicly visible or not. Set your repo to either: Public: Anyone on the internet can see this repository. You choose who can commit. Private: You choose who can see and commit to this repository. You can always change this in the settings of your repository later as well. Additionaly you can select whether you want to initialize your repository with a README file, a .gitignore file and a license. Once you have provided all the necessary information press the button Create repository at the bottom of the page. üéà Congrats on your Repo! üéâ Now go back to the page that lists all your repositories and open the repository that you have just created. There should be a green button named Code. Press that button and copy the provided URL. Open PowerShell on your machine and browse to your working folder. For this example I am using my home directory. cd $home clone your Repository by running the following command: git clone https://github.com/\u003cusername\u003e/\u003crepository\u003e.git replace the URL with the one you have copied earlier. Or just replace the tokens with your own details. There you go! You have your repository locally now. Awesome! I think? A bit empty though..? Hmm, lets work on that! ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:2:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"üìÇ Prepare your PowerShell repository // describe what it will look like e.g. design patterns / folder structure run Tree utility to show what mine looks like describe what comes later. E.g. .Github workflow, maybe .vscode/.devcontainer? (or out of scope?) First we will have to think about how we design our repository. We want an ordered folder structure. I have looked at what others have done and most of them have a similar structure as the one that I have used below. the tree command\r\rThe tree command displays the directory structure of a path or of the disk in a drive graphically. It‚Äôs a very useful tool to quickly get a grasp on how the folder structure is. Read more about this command here For the example below I ran the command: tree . /F. Where . is the current directory I‚Äôm in and /F to display files as well. \r\r In the root of the repository I have a README and License file. The README file is an important part of your repository. Actually, mine should get some love! üòÖ The .github and build_scripts folders can be ignored for now. We will cover this later once we start working on our pipeline. For now create a directory with the name of your module. This is where we are going to create our module and manifest files for our PowerShell module. Within the directory we just created, create another folder with the name functions. This is where we are going to place all our functions. JTAZ ‚îÇ LICENSE ‚îÇ README.md ‚îÇ Unit.Tests.xml ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ.github ‚îÇ ‚îî‚îÄ‚îÄ‚îÄworkflows ‚îÇ main.yml ‚îÇ ‚îú‚îÄ‚îÄ‚îÄbuild_scripts ‚îÇ build.ps1 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄjtAz ‚îÇ jtAz.psd1 ‚îÇ jtAz.psm1 ‚îÇ jtAz.Test.ps1 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄfunctions Get-jtAzProviderNamespace.ps1 Get-jtAzResourceTypes.ps1 Get-jtAzTemplate.ps1 Now that we have a skeleton of our PowerShell repository lets commit and push these changes to our repository on GitHub. To do this run the commands: git add . git commit -m \"first commit\" git push origin main Now if you check your repository on GitHub your code will be there as well. ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:3:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"‚ö° Functions! When you are creating a PowerShell module you are going to need to have one or more scripts/functions first. If you are new to functions have a look at this documentation. It might sound intimidating at first but it is a really straight forward process. Maybe you already have a script available that you might want to turn into a function (because you are using running that script quite often now that you think of it ü§î). Give it a shot! And if you don‚Äôt have anything existing yet try to come up with something and try doing it with PowerShell. I found myself looking at the Azure ARM template documentation quite often but usually need to only have a quick look for reference. So I thought maybe I can create a function that will just return the ARM (or Bicep) template from the docs onto my terminal window. So it doesn‚Äôt have to be revolutionary just try something that sounds useful to you. Dive in. That is how we learn üëç Once you have created your function save them in the .\\\u003cmodulename\u003e\\functions\\ folder. Now we can have a look what that psm1 file is all about. üê±‚Äçüèç ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:4:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"üì¶ The module file Next up we have our script module file. As described in the Microsoft documentation a module is: ‚ÄúA module is a set of related Windows PowerShell functionalities, grouped together as a convenient unit (usually saved in a single directory). By defining a set of related script files, assemblies, and related resources as a module, you can reference, load, persist, and share your code much easier than you would otherwise.‚Äù Create a file with the name of your module and save it with the .psm1 extension in the folder that also has your module name. Now we could have saved the code of our function in this module file and that would have been a valid and working approach. However, as you can imagine that might become quite cumbersome once you start adding additional functions and/or have to modify them. So instead of doing this we are going to use the functions subfolder, dot source each of our functions and export them. Save the following code in your module file: Set-StrictMode -Version Latest $functions = Get-ChildItem -Path $PSScriptRoot\\functions\\*.ps1 foreach ($import in $functions) { try { Write-Verbose \"Importing $($import.FullName)\" . $import.FullName } catch { Write-Error \"Failed to import function $($import.FullName): $_\" } } #foreach foreach ($file in $functions) { Export-ModuleMember -Function $file.BaseName } #foreach dot sourcing the functions will load the functions into memory without executing the code. ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:5:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"üìÑ The manifest file We are also going to create a manifest file (the one with the .psd1 extension). This is a file that will contain a hashtable with keys and values that describes everything about the module. Think prerequisites, what scripts need to be processed, metadata, versions, etc. We can simply create this file using the New-ModuleManifest PowerShell cmdlet. Checking the help for this cmdlet will give you all the details: Get-Help New-ModuleManifest -Full Now that we know what we can specify. Lets create one ourselves. Replace SomeModule with the name of your module and replace the values with your own. You can provide additional parameter if you want to. $ModuleName = 'SomeModule' $props = @{ Path = \"$ModuleName.psd1\" RootModule = \"$ModuleName.psm1\" GUID = \"$(New-Guid)\" Author = 'Jeroen Trimbach' CompanyName = 'N/A' Description = \"beep boop I'm backing up\" ModuleVersion = '9.9.9' # Leave as is! FunctionsToExport = @('\u003cFunctionsToExport\u003e') # leave as is! CmdletsToExport = @() VariablesToExport = @() AliasesToExport = @() } New-ModuleManifest @props ((Get-content -path \".\\$($ModuleName).psd1\") -replace '9.9.9','\u003cModuleVersion\u003e') | Set-Content -path \".\\$($ModuleName).psd1\" Have a check at the content of your newly created file. Uncomment keys that seem useful to you and provide values where required. We have not given any function names and module version intentionally. We are going to replace these in our actions workflow because as mentioned earlier whenever we create a new function we want our module to pick that up as well without having to edit the manifest file ourselves. This same idea applies to the ModuleVersion key. Future content :-) --\r ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:6:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"üñº PowerShellGallery The plan is that we are going to publish our module to the PowerShell Gallery. This is a free website maintained by Microsoft. Register on the website. Once you have an account in the Gallery we want to create a API key. Because whenever we want to publish any package to the PowerShell Gallery we are going to provide this key. Click on your Profile. It will show a button named API Keys. This will take you to the API Keys page. Click on Create. Provide a name for your key and give an amount of days until the key will expire. The default is 365 days. Now click on Create again at the bottom of the page. Copy the key that is displayed on the screen. Now we are going to store this key in a safe location from where we can use it in our next steps. Go to your Github repository and click on settings. There will be a menu item called Secrets. This will take you to the Actions secrets page. Click on New repository secret at the top right of the page. Provide a name for your secret (e.g. PSGALLERYAPIKEY) and provide your key. Click on save. Now we are completely set. Time for Actions! üí• ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:7:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"üî© GithHub Actions Oh, one more step. Remember the values we were going to replace in our manifest file? Lets do that now. Create a directory in the root of your repository with the name build_scripts or something similar if you haven‚Äôt already done so. Create a file in there with the name build.ps1. Set the content of that file to: $Global:ErrorActionPreference = 'Stop' $Global:VerbosePreference = 'SilentlyContinue' $buildVersion = $env:BUILDVER $manifestPath = \"./jtAz/jtAz.psd1\" $publicFuncFolderPath = './jtAz/functions' if (!(Get-PackageProvider | Where-Object { $_.Name -eq 'NuGet' })) { Install-PackageProvider -Name NuGet -force | Out-Null } Import-PackageProvider -Name NuGet -force | Out-Null if ((Get-PSRepository -Name PSGallery).InstallationPolicy -ne 'Trusted') { Set-PSRepository -Name PSGallery -InstallationPolicy Trusted } $manifestContent = (Get-Content -Path $manifestPath -Raw) -replace '\u003cModuleVersion\u003e', $buildVersion if ((Test-Path -Path $publicFuncFolderPath) -and ($publicFunctionNames = Get-ChildItem -Path $publicFuncFolderPath -Filter '*.ps1' | Select-Object -ExpandProperty BaseName)) { $funcStrings = \"'$($publicFunctionNames -join \"','\")'\" } else { $funcStrings = $null } $manifestContent = $manifestContent -replace \"'\u003cFunctionsToExport\u003e'\", $funcStrings $manifestContent | Set-Content -Path $manifestPath Now in your Github repository open the Actions menu. Click on the New workflow button. It will prompt you to choose a workflow template. We will go for set up a workflow yourself. This will open up a file called main.yml in \u003crepo\u003e/.github/workflows/. Replace the contents of that file with the following workflow: # This is a basic workflow to help you get started with Actionsname:CI# Controls when the workflow will runon:# Triggers the workflow on push or pull request events but only for the main branchpush:branches:[main ]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:publish-to-gallery:needs:buildruns-on:ubuntu-lateststeps:- uses:actions/checkout@v2- name:Build and publish# API key generated in PSGalleryenv:NUGET_KEY:${{ secrets.PSGALLERYAPIKEY }}BUILDVER:'1.0.0'shell:pwshrun:|./build_scripts/build.ps1 Publish-Module -path ./jtAz -NuGetApiKey $env:NUGET_KEY -Verbose Additionaly it might be a good idea to add a job that will run tests on your code first. For PowerShell using Pester is an excellent way to do that. Especially since it is automatic. I will update this post later to include some unit tests and how you can use them in your workflow. Now click on start commit. Select your workflow and Run workflow! Now it‚Äôs time to sit back and relax üçø Your workflow will run and if all goes well it will show a green checkmark ‚úÖ Which also means that you now have your module published to the PowerShell Gallery. They will also send you mail upon succes. If you get a failure message well then you know what that means.. troubleshoot time. This may or may not have happened to me a few times.. üôÇ ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:8:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation","Learning"],"content":"üí° Conclusion In this post we have learned how we can create a PowerShell module using functions that we have stored in separate ps1 files. We have started using a bit of git. And we know now how we can publish our modules to the PS Gallery by using a GitHub Actions workflow. There is still a lot of room for improvement. We definitely need some tests in there else we are stuck doing that manually and we don‚Äôt want that. If you want to learn more about PowerShell then I highly recommend reading through the two books that I have mentioned below. The books are very well written and I have learned a lot from them. Whenever I want to do something in PowerShell but not sure what the correct approach is I try to search in those books first. I will pick up something new most of the times as well. Learn PowerShell in a Month of Lunches - Don Jones, Jeffery Hicks Learn PowerShell Scripting in a Month of Lunches - Don Jones, Jeffery Hicks Good luck learning üëç ","date":"28-07-2021","objectID":"/2021/07/powershell-module-ci/:9:0","tags":["Blog","PowerShell","Module","GitHub Actions","YAML","CICD"],"title":"Lets create a PowerShell Module and publish it to the PSGallery using GitHub Actions!","uri":"/2021/07/powershell-module-ci/"},{"categories":["Documentation"],"content":"A write-up/step-by-step tutorial of I have setup my site using Hugo with the uBlogger theme and hosted it on GitHub Pages.","date":"19-06-2021","objectID":"/2021/06/site-setup/","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"A write-up/step-by-step tutorial of I have setup my site using Hugo with the uBlogger theme and hosted it on GitHub Pages. ","date":"19-06-2021","objectID":"/2021/06/site-setup/:0:0","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"üìã Prerequisites ","date":"19-06-2021","objectID":"/2021/06/site-setup/:1:0","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"[‚úî] Chocolatey I have used chocolatey for installing all pre-reqs. If you are also interested in using a package manager and don‚Äôt have Chocolatey installed yet you can do so by following the instructions on their website https://chocolatey.org/install. Or you can just open PowerShell as Admin and run the following script: Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) ","date":"19-06-2021","objectID":"/2021/06/site-setup/:1:1","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"[‚úî] Hugo Now lets put Chocolatey to use.. ;) From Powershell run the following install command: choco install hugo-extended -confirm The terminal should display a message saying that the installation was successful. We can verify this by running the command: hugo version ","date":"19-06-2021","objectID":"/2021/06/site-setup/:1:2","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"[‚úî] GIT And again using chocolatey we can simply install git by running: choco install git And once that is done we have everyting we need. The following are optional requirements but I do suggest having a look at them. ","date":"19-06-2021","objectID":"/2021/06/site-setup/:1:3","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"(‚úî) Optional [‚úî] 1. Domain Name The only cost we will have is having to buy a domain name. Unless of course you are ok with your site ending with github.io. We can always change this afterwards as well. You can buy a domain at any domain registrar. I bought my domain at Namecheap. [‚úî] 2. GitHub Account I am using GitHub pages to host my site. If you are interested in doing the same you should create a GitHub account if you don‚Äôt already have one. They have a free plan available and the process is straight forward. Just go to their site to sign up. [‚úî] 3. Visual Studio Code I highly suggest using a code editor. My editor of choice is Visual Studio Code. To install VS Code run: choco install vscode And of course if you prefer a different editor yourself than you can use that one instead. ","date":"19-06-2021","objectID":"/2021/06/site-setup/:1:4","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"‚ûï Create a Hugo site ","date":"19-06-2021","objectID":"/2021/06/site-setup/:2:0","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"1. Create a site folder Before we start let us create a directory in which our Hugo sites will be stored. For this demo I will use create a Hugo folder on C:. cd C:\\; mkdir Hugo | cd The command below will create a new Hugo site in a folder named ‚Äúsitefolder‚Äù in the current directory. If you want it to be created in a different location then change your working directory to the desired location. You can specify a name other than ‚Äúsitefolder‚Äù by just replacing it to whatever you like. hugo new site sitefolder ","date":"19-06-2021","objectID":"/2021/06/site-setup/:2:1","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"2. Add a theme for your site Before we can start deploying our site we need to pick a theme. There are a lot of which you can choose from https://themes.gohugo.io/. I am using the uBlogger theme (https://themes.gohugo.io/ublogger/). Once you have found your theme you will have to install it.\\ You can either download a zip file of the latest release of the theme and extract it in the themes directory, clone the themes GitHub repository to theme directory directly or create an empty git repository and make it a submodule of your site directory. I went with the latter. Now let‚Äôs change directory to our new site folder, create an empty git repository and download and add our new theme as a subdirectory. We do this by running: cd sitefolder git init git submodule add https://github.com/upagge/uBlogger.git themes/uBlogger Now that we have our theme we can add it as a default to our configuration file. In our sites directory we need to make some changes to the config.toml file to achieve this. So open the file in VS Code: code .\\config.toml And add these settings to the site configuration: # Default theme Theme = \"uBlogger\" [params] # uBlogger theme version Version = \"2.0.X\" Save the config.toml file and open your terminal again. From your site directory run: hugo serve Once the build succeeds the web server will be available at http://localhost:1313/ Open this site in your browser (ctrl + click in terminal to open). It is empty as of now but this is what we got as of now. You can leave your terminal open and make changes to the config or any content files. Any changes made will immediately reflect on the page. ","date":"19-06-2021","objectID":"/2021/06/site-setup/:2:2","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"3. Some more theme changes Our site as of now is still looking a bit empty.. time to change that. First we will have to make some changes to the configuration. We can have a peak at the sample site of our theme which is listed in the exampleSite folder of our themes directory. But the uBlogger theme also has a default configuration in their documentation. Which I am going to use for now. baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \"en\" # language code languageCode = \"en\" title = \"My New Hugo Site\" # Change the default theme to be use when building the site with Hugo theme = \"uBlogger\" [params] # uBlogger theme version version = \"2.0.X\" [menu] [[menu.main]] identifier = \"posts\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Posts\" url = \"/posts/\" # title will be shown when you hover on this menu link title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 # Markup related configuration in Hugo [markup] # Syntax Highlighting (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false is a necessary configuration noClasses = false Edit the config.toml file in our sites directory and paste this big chunk of config stuff in there. Before we start making more edits lets save the file and have a look at our site now. http://localhost:1313/ in case you closed your browser. Or if you have exit PowerShell run: hugo serve keep it running.. it is nice to see what is happening. Well, after changing the config we got a menu even a light/dark mode button. Neat! But.. our homepage is still looking empty. Time to config some more. We are going to add onto our param section: [params] # uBlogger theme version version = \"2.0.X\" # site default theme (\"light\", \"dark\", \"auto\") # defaultTheme = \"auto\" # public git repo url only then enableGitInfo is true # gitRepo = \"https://github.com/upagge/dolboblog-theme\" # which hash function used for SRI, when empty, no SRI is used (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # date format dateFormat = \"02-01-2006\" # website images for Open Graph and Twitter Cards # images = [\"/logo.png\"] # site description description = \"About uBlogger Theme\" # site keywords keywords = [\"Theme\", \"Hugo\"] # Search config # [params.search] # enable = true # # type of search engine (\"lunr\", \"algolia\") # type = \"algolia\" # # max index length of the chunked content # contentLength = 4000 # # placeholder of the search bar # placeholder = \"\" # # max number of results length # maxResultLength = 10 # # snippet length of the result # snippetLength = 30 # # HTML tag name of the highlight part in results # highlightTag = \"em\" # # whether to use the absolute URL based on the baseURL in search index # absoluteURL = false # [languages.en.params.search.algolia] # index = \"index.en\" # appID = \"PASDMWALPK\" # searchKey = \"b42948e51daaa93df92381c8e2ac0f93\" # Home page config [params.home] # amount of RSS pages rss = 10 # Home page profile [params.home.profile] enable = true # Gravatar Email for preferred avatar in home page gravatarEmail = \"\" # URL of avatar shown in home page avatarURL = \"\" #\"/images/avatar.png\" # title shown in home page (HTML format is supported) title = \"uBlogger | Hugo Theme\" # subtitle shown in home page (HTML format is supported) subtitle = \"A Clean, Elegant but Advanced Hugo Theme\" # whether to show social links social = true # disclaimer (HTML format is supported) disclaimer = \"\" # Home page posts [params.home.posts] enable = true # special amount of posts in each home posts page paginate = 6 # Social config in home page # There is a lot more available! Check out the exam","date":"19-06-2021","objectID":"/2021/06/site-setup/:2:3","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"4. Let‚Äôs create a post To create a new post we can simple run the new command from our sites directory. Make sure to specify the posts folder when you are creating a post. # Creating a post can be done using the new command hugo new posts/site-setup.md # Let's have a check and see what that did code .\\content\\posts\\site-setup.md Note that the content displayed is configured by the default.md file located in the archetypes folder. We can create a pre-configured post by replacing it with our themes default.md file located in /theme/uBlogger/archetypes. For now lets just edit the title of our post, set draft to false and write some sample text below the last ‚Äú‚Äî‚Äù. Once you have done that save the file. What are you waiting for? Check out your site :) ","date":"19-06-2021","objectID":"/2021/06/site-setup/:2:4","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"üåê Hosting your site (on GitHub) I hope by now the process of creating and tweaking your site. Now it is time to share our creation with others. ","date":"19-06-2021","objectID":"/2021/06/site-setup/:3:0","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"1. Build the static pages First we will have to build the static pages. We can achieve this by running the command: hugo # or if you want to include draft posts: hugo -D Your output will be in the public directory of your site. ","date":"19-06-2021","objectID":"/2021/06/site-setup/:3:1","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"2. Create your site‚Äôs GitHub repository Sign in to your GitHub account and click on ‚ÄúCreate a new repository‚Äù. In order to host your generated content you must use a repo name of the following format: YOURUSERNAME.github.io Also if you are using a free account make sure to leave the repository Public. All other boxes can be left unchecked. ","date":"19-06-2021","objectID":"/2021/06/site-setup/:3:2","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"3. Push our site‚Äôs static pages to our repo Back on our local machine. Make sure your working directory is the public directory. From there run the following: git init git add . git remote add origin https://github.com/YOURUSERNAME/YOURUSERNAME.github.io.git git commit -m \"commit\" git push origin master Once completed go back to your GitHub repository. Your files are now stored in your repository and your site should display by following the link http://YOURUSERNAME.github.io ","date":"19-06-2021","objectID":"/2021/06/site-setup/:3:3","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"4. Add your own domain name @ GitHub Go to the settings of your repository. On the sidebar click the ‚ÄòPages‚Äô button. Under ‚Äòcustom domain‚Äô specify your own domain name (e.g. www.jeroentrimbach.com) and click save. A file with the name CNAME will be created in your repository with your specified domain name as its content. @ your Domain Registrar This may differ per Domain Registrar but the process shouldn‚Äôt be too difficult. Log in to your domain registrar‚Äôs account manager, select your domain name and go to the DNS settings. Create a CNAME record that points your domain name to your github.io site. It will show like this: Type Host Value TTL CNAME www jeroen-t.github.io automatic @ GitHub Go back to the settings of your sites repository and go to back to where you added your custom domain. After a while your validation will pass. Optionally you can also enforce HTTPS for your site but it may take a while before you can check that box. You can come back later to do this. ","date":"19-06-2021","objectID":"/2021/06/site-setup/:3:4","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"5. Pull the CNAME file to your site locally From your local machine make sure the working directory is the public folder. We are now going to pull the CNAME file that we created in GitHub to make sure it is included in future builds. git pull origin master ","date":"19-06-2021","objectID":"/2021/06/site-setup/:3:5","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"‚Üî Switching your theme? readme\r\rYou can skip this section if you are happy with your theme. If you want to try out another then I suggest reading this :-)\r\r If you have found another theme that you want to use then simply copy the url of the theme‚Äôs repository. You can then add the theme to your sites repository as a submodule just like we have done before. E.g.: git submodule add https://github.com/khusika/FeelIt themes/FeelIt And in your config.toml file update the theme to the name of your new theme. For me that is: theme = \"FeelIt\" Time to check out our new theme (no errors pls ü§û) hugo serve And if all looks good lets publish our updated site by running: hugo cd .\\public\\ git add . git commit -m \"new theme\" git push origin master Looking good! If you are happy with your new theme and you are sure that you are not going to use your old theme again you may want to remove it. You can do so by running the following commands from your site‚Äôs home directory: git submodule deinit \\themes\\\u003coldtheme\u003e git rm \\themes\\\u003coldtheme\u003e git commit -m \"removed old themes submodule\" rm -r -f .git/modules/themes/\u003coldtheme\u003e Poof.. done with our cleanup üßπ ","date":"19-06-2021","objectID":"/2021/06/site-setup/:4:0","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Documentation"],"content":"üí° Conclusion Basic flow for writing and publishing a new post So now we have our site hosted on GitHub pages and we are able to access it through our own custom domain. Sweet! üòç But what if we want to publish new content? We have learned how to create a new post. # set site as working directory cd sitefolder # create a new hugo post hugo new posts\\new-post.md # edit your post in vs code code .\\content\\posts\\new-post.md # and save.. # check locally if we achieved the desired result hugo serve # open http://localhost:1313/ in your browser # ctrl + C to exit When we are happy with our newly created content then we can build the static pages using the hugo command. Followed by pushing our static pages in the public folder to our GitHub repo. # build static pages hugo # or if including drafts: hugo -D # change the to the public directory cd ./public git add . git commit -m \"commit\" git push origin master That‚Äôs it! Now if we refresh our site it should contain the newly created content. Have fun! üëç ","date":"19-06-2021","objectID":"/2021/06/site-setup/:5:0","tags":["Blog","Setup","GitHub Pages"],"title":"How to create a website using Hugo and GitHub Pages","uri":"/2021/06/site-setup/"},{"categories":["Career"],"content":"whoami","date":"18-06-2021","objectID":"/about/","tags":["Career"],"title":"About Me","uri":"/about/"},{"categories":["Career"],"content":"EXPERIENCE ","date":"18-06-2021","objectID":"/about/:1:0","tags":["Career"],"title":"About Me","uri":"/about/"},{"categories":["Career"],"content":"Deloitte | Azure Cloud Engineer July 2021 - Present ","date":"18-06-2021","objectID":"/about/:1:1","tags":["Career"],"title":"About Me","uri":"/about/"},{"categories":["Career"],"content":"Deloitte | SQL DBA Azure Engineer March 2019 - Present ","date":"18-06-2021","objectID":"/about/:1:2","tags":["Career"],"title":"About Me","uri":"/about/"},{"categories":["Career"],"content":"Deloitte | SQL Database Administrator September 2018 - March 2019 ","date":"18-06-2021","objectID":"/about/:1:3","tags":["Career"],"title":"About Me","uri":"/about/"},{"categories":["Career"],"content":"Didacticum Groep | SQL DBA Trainee July 2018 - March 2019 ","date":"18-06-2021","objectID":"/about/:1:4","tags":["Career"],"title":"About Me","uri":"/about/"},{"categories":["Career"],"content":"Education ","date":"18-06-2021","objectID":"/about/:2:0","tags":["Career"],"title":"About Me","uri":"/about/"},{"categories":["Career"],"content":"Amsterdam University of Applied Sciences 2013 - 2018 Bachelor of Science (BSc.), Mathematical Engineer Certifications \u0026 Exams \r\r\r\r\r","date":"18-06-2021","objectID":"/about/:2:1","tags":["Career"],"title":"About Me","uri":"/about/"}]